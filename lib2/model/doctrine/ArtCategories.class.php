<?php

/**
 * ArtCategories
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    stgcms2
 * @subpackage model
 * @author     Jerzy Biernacki <jurek@studiotg.pl>, Paweł Sałajczyk <pawel@studiotg.pl>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class ArtCategories extends BaseArtCategories implements StgTreDoctrineRecordInterface
{
    public static function getArtCategoriesTreeKeys()
    {
        return explode(',', stgConfig::get('art_categories_tree_keys'));
    }

    public function isEditableRoot() // dla StgTree
    {
      return ($this->getLevel() == 0 && $this->getIsPublic()) ? true : false; //jeśli w backendzie ma być niewidoczny root, to wystarczy ustawić is_public roota na 0
    }

    public function __toString()
    {
        return $this->getName();
    }

    public function getIndentedName()
    {
        return str_repeat('- ', $this->getLevel()) . ' ' . $this->getName();
    }

    /**
     * Ta metoda jest po to, żeby ograniczyć zapytania, które powstają przy getNode()->hasChildren()
     */
    public function hasChildren() {
      return $this->getRgt() - $this->getLft() > 1;
    }

    /**
     * XXX: Ta metoda to kondydat do wywalenia
     */
    public function setPublic($f)
    {
        $this->setIsPublic($f);
        $this->save();

        return true;
    }

    public function renderLink() { //TODO: DRY + zmieniać route w zależności od tego, czy to ArtCategories czy kategoria katalogu
      sfContext::getInstance()->getConfiguration()->loadHelpers(array('Url'));
      return '<a href="'.url_for('art_category_show', $this).'">'.$this->getName().'</a>';
    }

    public function getAncestorsArrayByIds($get_root = false) {  //TODO: DRY
      $ancestors_ids = array();
      if ($ancestors = ($get_root) ? $this->getNode()->getAncestors() : $this->getAncestorsWithoutRoot()) {
        foreach ($ancestors as $ancestor) {
          $ancestors_ids[$ancestor->getPrimaryKey()] = $ancestor;
        }
      }

      return $ancestors_ids;
    }

    public function hasArtCategory($value, $field)
    {
        $artCategory = $this;
        $artCategories = $artCategory->getNode()->getAncestors();
        $artCategories[] = $artCategory;

        foreach ($artCategories as $artCategory) {
          if ($artCategory->get($field) == $value) {
            return true;
          }
        }
        return false;
    }

    public function queryActiveProducts() {
      $q = Doctrine_Query::create()
                      ->from('Articles a')
                      ->leftJoin('a.ArtCategories ac')
                      ->andWhere('a.is_public = true')
                      ->andWhere('ac.lft >= ?', $this->getLft())
                      ->andWhere('ac.rgt <= ?', $this->getRgt())
                      ->andWhere('ac.root_id = ?', $this->getRootId())
                      ;

      return $q;
//      return Doctrine_Core::getTable('Articles')->queryActive($q, array('alias' => 'a'));
    }

    public function renderLinkWithAncestors() { //TODO: DRY
      $return = '';
      $first = true;
      $categories = $this->getAncestorsWithoutRoot();
      $categories->add($this);
      foreach ($categories as $category) {
        if ($first) {
          $first = false;
        }
        else {
          $return .= ' » ';
        }
        $return .= $category->renderLink();
      }

      return $return;
    }

    public function getAncestorsWithoutRoot() {  //TODO: DRY
      return $this->getTable()->getAncestorsWithoutRoot($this);
    }

    public function renderAncestorsLinks() { //TODO: DRY
      $return = '';
      $first = true;
      $categories = $this->getAncestorsWithoutRoot();
      $categories->add($this);
      $i = 0;
      foreach ($categories as $category) {
        $i++;
        if ($i == count($categories)) {
          break;
        }
        if ($first) {
          $first = false;
        }
        else {
          $return .= ' » ';
        }
        $return .= $category->renderLink();
      }

      return $return;
    }

    /**
     * SAVES TRANSLATIONS
     */
    public function initalizeTranslations() {
      foreach(Lang::getInstance()->getAll()->toArray() as $lang) { //foreach language
        $this->Translation[$lang]; //nic z tym nie robię - wystarczy, że to się zainicjalizuje w obiekcie
      }
    }

    public function save(Doctrine_Connection $conn = null)
    {
        // Dodawanie galerii
        $gallery = ($this->Galleries->count()) ? $this->Galleries : new Galleries();
        $gallery->setName('Galeria kategorii: '.$this->getName());
        $gallery->setIsDeletable(false);
        $gallery->setIsEditable(false);
        $this->Galleries = $gallery;

        $this->initalizeTranslations(); // żeby zapisały się wersje językowe

        T::cc('frontend');
        DoctrineBugfixesclass::generateSlugOnUpdatedObjectWithI18n($this, $conn, 'name');

        if ($this->isNew()) { $this->Metas = Metas::createAndSave(); }
        
        $r = parent::save($conn);

        $this->Metas->generateMetas($this);
        return $r;
    }

    public function delete(Doctrine_Connection $conn = null)
    {
      if ($this->getIsDeletable()) {
        // usuwanie artykułów z tej kategorii <- powinno to być załatwione przez ondelete: CASCADE, ale z jakiegoś powodu metoda delete z ArtCategories nie wywołuje metod delete z Articles (może dlatego, że ArtCategories to NestedSet? )
        $root_artcategory = Doctrine::getTable('ArtCategories')->findOneByTreeKey('ARTICLES_TREE')->getPrimaryKey();

        foreach ($this->getArticles() as $article) {
//          $article->delete();
          $article->set('artcategory_id', $root_artcategory);
          $article->save();
        }
       
        
        Menus::clearMenuIfNeeded($this);

        Metas::deleteByObject($this);
        
        T::cc('frontend');
        
        return parent::delete($conn);
      }
    }

    public function getArticlesQuery()
    {
        $artCategoriesIds = array();
        $descendants = $this->getNode()->getDescendants();
        if ($descendants && count($descendants)) {
          $artCategoriesIds = $descendants->getPrimaryKeys();
        }
        $artCategoriesIds[] = $this->getPrimaryKey();

        $q = Doctrine_Query::create()
            ->from('Articles b')
            ->leftJoin('b.ArtCategories c')
            ->leftJoin('b.Galleries g')			
//            ->where('b.artcategory_id = '.$this->getArtcategoryId())
            ->andWhereIn('b.artcategory_id', $artCategoriesIds)
            ->andWhere('b.is_public = ?',true)
            ->orderBy('b.created_at desc');
        return $q;
    }

}
